unit orm.dao.BaseDAO;

interface

uses
     Db,
     Rtti,
     ZDataset,
     uRESTDWBasicDB,
     Generics.Collections,
     uRESTDWIdBase,
     Datasnap.DBClient,
     Vcl.Forms,
     orm.conexao.ModelConexaoFactory,
     orm.IBaseVO,orm.Atributos,
     orm.Lib.Biblioteca,
     orm.conexao.interfaces.Interfaces,
     orm.conexao.model_rdw.ModelRDWQuery,
     orm.lib.RttiUtils,
     System.SysUtils,
     System.JSON,
     System.Contnrs,
     System.Classes;
  type
    TBaseDAO<T : class, constructor> = class(TInterfacedObject, IDAO<T>)
      private
        FQuery: IModelQuery;
        FDataSource: TDataSource;
        FLista: TObjectList<T>;
        FForm: TForm;
        function FormatarString(aCampos: string): string;
        function PreencherParametro(aEntidade: T; aId: Variant): IDAO<T>;
      public
        constructor Create(aQuery: IModelQuery);
        destructor Destroy(); override;
        class function New(aQuery: IModelQuery): IDAO<T>;
        function Inserir(obj: T): IDAO<T>;
        function Atualizar(obj: T): IDAO<T>;overload;
        function Atualizar(obj, objOld: T): IDAO<T>;overload;
        function Excluir(obj: T): IDAO<T>;
        function Listagem(obj: T; const TipoJuncao:TTipoJoin = ttLeftJoin; aTemLista: boolean = True): IDAO<T>;overload;
        function Listagem(obj: T; dataInicio,dataFim: string; const TipoJuncao: TTipoJoin = ttLeftJoin): IDAO<T>;overload;
        function Listagem(obj: T; aId: integer; const TipoJuncao: TTipoJoin = ttLeftJoin): IDAO<T>;overload;
        function Listagem(obj: T; aNome: string; const TipoJuncao:TTipoJoin = ttLeftJoin): IDAO<T>; overload;
        //function Listagem(obj: T;dataInicio,dataFim: string; const TipoJuncao:TTipoJoin = ttLeftJoin; ConsultaCompleta: boolean = True): IDAO<T>; overload;
        function DataSource(aDataSource: TDataSource): IDAO<T>;
        function ConsultaSql(sql: string): TDataSet;overload;
        procedure OnDataChange(Sender: TObject; Field: TField);
        function Bind(aForm: TForm): IDAO<T>;
        {Fazer mais um método de atualização e mais listagem com vários retornos DataSet, IBaseVO, Listagem e Json}
    end;

implementation

{ TBaseDAO }

function TBaseDAO<T>.Atualizar(obj: T): IDAO<T>;
var
  contexto: TRttiContext;
  tipo: TRttiType;
  propriedade: TRttiProperty;
  atributos: TCustomAttribute;
  strUpdate,strCampos,strWhere, strTabela: string;
  Lib: TLib<T>;
begin
  Result := Self;
  strUpdate := 'UPDATE [TABELA] SET [CAMPOS] WHERE [CONDICAO]';
  strCampos := '';
  strWhere := '';
  strTabela := '';
  contexto := TRttiContext.Create;
  try
    tipo := contexto.GetType(obj.ClassInfo);
    //pegar o nome da tabela.
    for atributos in tipo.GetAttributes do
    begin
      if atributos is TTabela then
         strTabela := strTabela + TTabela(atributos).Nome;
    end;

    //pegar o nome dos campos e seus valores.
    for propriedade in tipo.GetProperties do
       for atributos in propriedade.GetAttributes do
       begin
         if not(strCampos = '') then
            strCampos := strCampos + ',';

         if atributos is TCampoTexto then
         begin
           strCampos := strCampos + TCampoTexto(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;
         end;

         if atributos is TCampoInteiro then
            strCampos := strCampos + TCampoInteiro(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;

         if atributos is TCampoData then
            strCampos := strCampos + TCampoData(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;

         if atributos is TCampoDataHora then
            strCampos := strCampos + TCampoDataHora(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;

         if atributos is TCampoExtended then
            strCampos := strCampos + TCampoExtended(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;

         if atributos is TCampoMonetario then
            strCampos := strCampos + TCampoMonetario(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;

         if atributos is TCampoBooleano then
            strCampos := strCampos + TCampoBooleano(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;

         if atributos is TChaveEstrangeira then
            strCampos := strCampos + TChaveEstrangeira(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;

         //Pegar a chave primária para colocar na clausula WHERE.
         if atributos is TChavePrimaria then
            strWhere := strWhere + TChavePrimaria(atributos).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;
       end;

       //Formatar a string que contém os campos e valores.
       strCampos := FormatarString(strCampos);

       //Montar a query.
       Lib := TLib<T>.Create;
       try
         strUpdate := Lib.LocalizarSubstituir(strUpdate,'[TABELA]', strTabela);
         strUpdate := Lib.LocalizarSubstituir(strUpdate,'[CAMPOS]', strCampos);
         strUpdate := Lib.LocalizarSubstituir(strUpdate,'[CONDICAO]',strWhere);
       finally
         Lib.Free;
       end;

      { 2 Camadas cliente-servidor.
      //Executar query. Opção 2 é para usar o zeos.
       FQuery := TModelConexaoFactory.New.Query(2).ExecSql(strUpdate);
       if (FQuery as TZQuery).RecordCount > 0 then
          Result := True
       else Result := False;}

       //Rest Dataware 3 camadas.
       FQuery.SQL.Clear;
       FQuery.SQL.Add(strUpdate);
       FQuery.ExecSql;
  finally
    contexto.Free;
  end;
end;

function TBaseDAO<T>.Atualizar(obj, objOld: T): IDAO<T>;
var contexto: TRttiContext;
    tipo, tipoOld: TRttiType;
    propriedade, propriedadeOld: TRttiProperty;
    atributos, atributoOld: TCustomAttribute;
    strUpdate, strTabela, strWhere, strCampos, nomeTipo: string;
    Lib: TLib<T>;
    valorNovo,valorAntigo: variant;
    achouValorAntigo: boolean;
begin
   Result := Self;
   strUpdate := 'UPDATE [TABELA] SET [CAMPOS] WHERE [CONDICAO]';
   strTabela := '';
   strWhere := '';
   strCampos := '';
   contexto := TRttiContext.Create();
   try
     tipo := contexto.GetType(Obj.ClassType);
     tipoOld := contexto.GetType(objOld.ClassType);
     for atributos in tipo.GetAttributes do
     begin
       if atributos is TTabela then
         strTabela := strTabela + TTabela(atributos).Nome;
     end;
     for propriedade in tipo.GetProperties do
     begin
       for atributos in propriedade.GetAttributes do
       begin
         if atributos is TCampoTexto then
         begin
           achouValorAntigo := False;
           valorNovo := propriedade.GetValue(TObject(Obj)).AsString;
         end;
         if atributos is TCampoInteiro then
         begin
           achouValorAntigo := False;
           valorNovo := propriedade.GetValue(TObject(obj)).AsInteger;
         end;
         if atributos is TCampoData then
         begin
           achouValorAntigo := False;
           valorNovo := propriedade.GetValue(TObject(obj)).AsString;
         end;
         if atributos is TCampoDataHora then
         begin
           achouValorAntigo := False;
           valorNovo := propriedade.GetValue(TObject(obj)).AsString;
         end;
         if atributos is TCampoMonetario then
         begin
           achouValorAntigo := False;
           valorNovo := propriedade.GetValue(TObject(obj)).AsCurrency;
         end;
         if atributos is TCampoExtended then
         begin
           achouValorAntigo := False;
           valorNovo := propriedade.GetValue(TObject(obj)).AsExtended;
         end;
         if atributos is TCampoBooleano then
         begin
           achouValorAntigo := False;
           valorNovo := propriedade.GetValue(TObject(obj)).AsBoolean;
         end;
       end;
       for propriedadeOld in tipoOld.GetProperties do
       begin
         for atributoOld in propriedadeOld.GetAttributes do
         begin
           if strCampos <> EmptyStr then
              strCampos := strCampos + ',';
           if atributoOld is TCampoTexto then
           begin
             if TCampoTexto(atributoOld).Nome = TCampoTexto(atributos).Nome then
             begin
               achouValorAntigo := True;
               valorAntigo := propriedadeOld.GetValue(TObject(objOld)).AsString;

               if valorNovo <> valorAntigo then
               begin
                 if propriedade.PropertyType.TypeKind in [tkString, tkUString, tkUnicodeString] then
                    strCampos := strCampos + TCampoTexto(atributos).Nome + '=' + QuotedStr(propriedade.GetValue(TObject(obj)).AsString)
                 else  strCampos := strCampos + TCampoTexto(atributos).Nome + '=' + 'null';
               end;
             end;
           end;
           if atributoOld is TCampoInteiro then
           begin
             if TCampoInteiro(atributoOld).Nome = TCampoInteiro(atributos).Nome then
             begin
               achouValorAntigo := True;
               valorAntigo := propriedadeOld.GetValue(TObject(objOld)).AsInteger;

               if valorNovo <> valorAntigo then
               begin
                 if propriedade.PropertyType.TypeKind in [tkInteger, tkInt64] then
                 begin
                   if propriedade.GetValue(TObject(obj)).AsInteger <> 0 then
                      strCampos := strCampos + TCampoInteiro(atributos).Nome + '=' + propriedade.GetValue(TObject(obj)).AsString
                   else strCampos := strCampos + TCampoInteiro(atributos).Nome + '=' + 'null';
                 end
               end;
             end;
           end;
           if atributoOld is TCampoData then
           begin
             if TCampoData(atributoOld).Nome = TCampoData(atributos).Nome then
             begin
               achouValorAntigo := True;
               valorAntigo := propriedadeOld.GetValue(TObject(objOld)).AsExtended;

               if valorNovo <> valorAntigo then
               begin
                 if propriedade.PropertyType.TypeKind = tkFloat then
                 begin
                   if propriedade.GetValue(TObject(obj)).AsExtended <> 0 then
                   begin
                     nomeTipo := lowercase(propriedade.PropertyType.Name);
                     if nomeTipo = 'tdate' then
                        strCampos := strCampos + TCampoData(atributos).Nome + '=' + FormatDateTime(TCampoData(atributos).Mascara, propriedade.GetValue(TObject(obj)).AsExtended);
                   end;
                 end;
               end;
             end;
           end;
           if atributoOld is TCampoDataHora then
           begin
             if TCampoDataHora(atributoOld).Nome = TCampoDataHora(atributos).Nome then
             begin
               achouValorAntigo := True;
               valorAntigo := propriedadeOld.GetValue(TObject(objOld)).AsExtended;

               if valorNovo <> valorAntigo then
               begin
                 if propriedade.PropertyType.TypeKind = tkFloat then
                 begin
                   if propriedade.GetValue(TObject(obj)).AsExtended <> 0 then
                   begin
                     nomeTipo := LowerCase(propriedade.PropertyType.Name);
                     if nomeTipo = 'tdatetime' then
                        strCampos := strCampos + TCampoDataHora(atributos).Nome + '=' + FormatDateTime(TCampoDataHora(atributos).Mascara, propriedade.GetValue(TObject(obj)).AsExtended);
                   end;

                 end;
               end;
             end;
           end;
           if atributoOld is TCampoExtended then
           begin
             if TCampoExtended(atributoOld).Nome = TCampoExtended(atributos).Nome then
             begin
               achouValorAntigo := True;
               valorAntigo := propriedade.GetValue(TObject(objOld)).AsExtended;

               if valorNovo <> valorAntigo then
               begin
                 if propriedade.PropertyType.TypeKind = tkFloat then
                 begin
                   if propriedade.GetValue(TObject(obj)).AsExtended <> 0 then
                   begin
                     nomeTipo := LowerCase(propriedade.PropertyType.Name);
                     if nomeTipo = 'textended' then
                        strCampos := strCampos + TCampoExtended(atributos).Nome + '=' + FormatFloat(TCampoExtended(atributos).Mascara, propriedade.GetValue(TObject(obj)).AsExtended);
                   end;
                 end;
               end;
             end;
           end;
           if atributoOld is TCampoMonetario then
           begin
             if TCampoMonetario(atributoOld).Nome = TCampoMonetario(atributos).Nome then
             begin
               achouValorAntigo := True;
               valorAntigo := propriedade.GetValue(TObject(objOld)).AsCurrency;

               if valorNovo <> valorAntigo then
               begin
                 if propriedade.PropertyType.TypeKind = tkFloat then
                 begin
                   if propriedade.GetValue(TObject(obj)).AsCurrency <> 0 then
                   begin
                     strCampos := strCampos + TCampoMonetario(atributos).Nome + '=' + FormatCurr(TCampoMonetario(atributos).Mascara, propriedade.GetValue(TObject(obj)).AsCurrency);
                   end;
                 end;
               end;
             end;
           end;
           if atributoOld is TCampoBooleano then
           begin
             if TCampoBooleano(atributoOld).Nome = TCampoBooleano(atributos).Nome then
             begin
               achouValorAntigo := True;
               valorAntigo := propriedade.GetValue(TObject(objOld)).AsBoolean;

               if valorNovo <> valorAntigo then
               begin
                 if not propriedade.GetValue(TObject(obj)).AsBoolean then
                    strCampos := strCampos + TCampoBooleano(atributos).Nome + '=' + propriedade.GetValue(TObject(obj)).AsString;
               end;
             end;
           end;
         end;
         if atributos is TChavePrimaria then
            strWhere := strWhere + TChavePrimaria(atributos).Nome + '=' + propriedade.GetValue(TObject(obj)).AsString;
       end;
       if achouValorAntigo then
          break;
     end;
     //Formatar a string que contém os campos e valores.
     strCampos := FormatarString(strCampos);

     Lib := TLib<T>.Create;
     try
       strUpdate := Lib.LocalizarSubstituir(strUpdate, '[TABELA]', strTabela);
       strUpdate := Lib.LocalizarSubstituir(strUpdate, '[CAMPOS]', strCampos);
       strUpdate := Lib.LocalizarSubstituir(strUpdate, '[CONDICAO]', strWhere);
     finally
       Lib.Free;
     end;

     FQuery.SQL.Clear;
     FQuery.SQL.Add(strUpdate);
     FQuery.ExecSql;
   finally
     contexto.Free;
   end;
end;

function TBaseDAO<T>.Bind(aForm: TForm): IDAO<T>;
begin
  Result := Self;
  FForm := aForm;
end;

function TBaseDAO<T>.ConsultaSql(sql: string): TDataSet;
begin
  raise Exception.Create('Falta implementar esse método');
end;

constructor TBaseDAO<T>.Create(aQuery: IModelQuery);
begin
   FQuery := aQuery;
   FLista := TObjectList<T>.Create;
end;

function TBaseDAO<T>.DataSource(aDataSource: TDataSource): IDAO<T>;
begin
  Result := Self;
  FDataSource := aDataSource;
  FDataSource.DataSet := FQuery.DataSet;
  FDataSource.OnDataChange := OnDataChange;
end;

destructor TBaseDAO<T>.Destroy;
begin
  if assigned(FLista) then
     FLista.Free;
  inherited;
end;

function TBaseDAO<T>.Excluir(obj: T): IDAO<T>;
var
  contexto: TRttiContext;
  tipo: TRttiType;
  propriedade: TRttiProperty;
  atributo: TCustomAttribute;
  strDelete,strTabela,strCondicao, strWhere: string;
  Lib: TLib<T>;
begin
   Result := Self;
   strDelete := 'DELETE FROM [TABELA] WHERE [CONDICAO]';
   strTabela := '';
   strCondicao := '';
   contexto := TRttiContext.Create;
   try
     tipo := contexto.GetType(obj.ClassInfo);
     //pegar o nome da tabela.
     for atributo in tipo.GetAttributes do
     begin
       if atributo is TTabela then
          strTabela := strTabela + TTabela(atributo).Nome;
     end;

     //pegar a condição da clausula WHERE.
     for propriedade in tipo.GetProperties do
       for atributo in propriedade.GetAttributes do
       begin
         if atributo is TChavePrimaria then
            strWhere := strWhere + TChavePrimaria(atributo).Nome + '= ' + propriedade.GetValue(TObject(obj)).ToString;
       end;

       //Montar query.
       Lib := TLib<T>.Create;
       try
         strDelete := Lib.LocalizarSubstituir(strDelete,'[TABELA]',strTabela);
         strDelete := Lib.LocalizarSubstituir(strDelete,'[CONDICAO]',strWhere);
       finally
         Lib.Free;
       end;

       //Executar a query. Clinte e Servidor
       {FQuery := TModelConexaoFactory.New.Query(2).ExecSql(strDelete);
       if (FQuery as TZQuery).RecordCount > 0 then
          Result := True
       else Result := False;}

       //Rest Dataware n camadas.
       FQuery.SQL.Clear;
       FQuery.SQL.Add(strDelete);
       FQuery.ExecSql;
   finally
     contexto.Free;
   end;
end;

function TBaseDAO<T>.FormatarString(aCampos: string): string;
var sCampos: TSTringList;
    i, iRetorno: integer;
    sRetorno: string;
begin
   sCampos := TStringList.Create;
   try
     iRetorno := ExtractStrings([','], [], PWideChar(aCampos), sCampos);
     if iRetorno > 0 then
     begin
       for i := 0 to sCampos.Count - 1 do
       begin
         if not sRetorno.IsEmpty then
            sRetorno := sRetorno + ',';
         sRetorno := sRetorno + sCampos[i];
       end;
     end;
     Result := sRetorno;
   finally
     sCampos.Free;
   end;
end;

function TBaseDAO<T>.Inserir(obj: T): IDAO<T>;
var
  contexto: TRttiContext;
  tipo: TRttiType;
  propriedade: TRttiProperty;
  atributos: TCustomAttribute;
  strInsert, strCampos,strValores,strTabela: string;
  Lib: TLib<T>;
begin
   Result := Self;
   strInsert := 'INSERT INTO [TABELA]([CAMPOS]) VALUES([VALORES]) RETURNING ID';
   strCampos := '';
   strValores := '';
   strTabela := '';
   contexto := TRttiContext.Create;
   try
     tipo := contexto.GetType(obj.ClassInfo);
     //Pegar o nome da tabela.
     for atributos in tipo.GetAttributes do
     begin
       if atributos is TTabela then
         strTabela := strTabela + TTabela(atributos).Nome;
     end;

     //Pegar os campos da tabela.
     for propriedade in tipo.GetProperties do
       for atributos in propriedade.GetAttributes do
        begin

          if not(strCampos = '') then
             strCampos := strCampos + ',';

          if atributos is TCampoTexto then
            strCampos := strCampos + TCampoTexto(atributos).Nome;

          if atributos is TCampoInteiro then
            strCampos := strCampos + TCampoInteiro(atributos).Nome;

          if atributos is TCampoData then
            strCampos := strCampos + TCampoData(atributos).Nome;

          if atributos is TCampoDataHora then
            strCampos := strCampos + TCampoDataHora(atributos).Nome;

          if atributos is TCampoExtended then
             strCampos := strCampos + TCampoExtended(atributos).Nome;

          if atributos is TCampoMonetario then
             strCampos := strCampos + TCampoMonetario(atributos).Nome;

          if atributos is TCampoBooleano then
             strCampos := strCampos + TCampoBooleano(atributos).Nome;

          if atributos is TChaveEstrangeira then
             strCampos := strCampos + TChaveEstrangeira(atributos).Nome;
        end;

        //Pegar os valores os campos.
        for propriedade in tipo.GetProperties do
        begin
          for atributos in propriedade.GetAttributes do
          begin
            if not(strValores = '') then
               strValores := strValores + ',';

            if atributos is TCampoTexto then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;

            if atributos is TCampoInteiro then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;

            if atributos is TCampoData then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;

            if atributos is TCampoDataHora then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;

            if atributos is TCampoExtended then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;

            if atributos is TCampoMonetario then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;

            if atributos is TCampoBooleano then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;

            if atributos is TChaveEstrangeira then
               strValores := strValores + propriedade.GetValue(TObject(obj)).ToString;
          end;
        end;

        //Formatar string que contém os campos que irão ser inseridos.
        strCampos := FormatarString(strCampos);
        strValores := FormatarString(strValores);

        //Montar a query.
        Lib := TLib<T>.Create;
        try
          strInsert := Lib.LocalizarSubstituir(strInsert,'[TABELA]',strTabela);
          strInsert := Lib.LocalizarSubstituir(strInsert,'[CAMPOS]',strCampos);
          strInsert := Lib.LocalizarSubstituir(strInsert,'[VALORES]',strValores);
        finally
          Lib.Free;
        end;

        //Executar a query.
        {  Cliente e servidor.
        FQuery := TModelConexaoFactory.New.Query(2).ExecSql(strInsert);
        if (FQuery as TZQuery).RecordCount > 0 then
            Result := True
        else Result := False;}

        //Rest Dataware n camadas.
        FQuery.SQL.Clear;
        FQuery.SQL.Add(strInsert);
        FQuery.ExecSql;
   finally
     contexto.Free;
   end;
end;

function TBaseDAO<T>.Listagem(obj: T; dataInicio, dataFim: string;
  const TipoJuncao: TTipoJoin): IDAO<T>;
var
  contexto: TRttiContext;
  tipo: TRttiType;
  prop: TRttiProperty;
  atributo: TCustomAttribute;
  json: TJSONObject;
  Lib: TLib<T>;
  strSelect, strCampos, strTabela, strJuncao, strWhere, alias, aliasEstrangeiro: string;
begin
   Result := Self;
   strSelect := 'SELECT [CAMPOS] FFOM [TABELA] [JUNCAO] WHERE [CONDICAO]';
   strCampos := '';
   strTabela := '';
   strJuncao := '';
   strWhere := '';
   json := TJSONObject.Create;
   contexto := TRttiContext.Create;
   try
      tipo := contexto.GetType(TObject(obj).ClassInfo);
      for atributo in tipo.GetAttributes do
      begin
         if atributo is TTabela then
         begin
           alias := TTabela(atributo).Alias;
           strTabela := strTabela + TTabela(atributo).Nome + ' ' + TTabela(atributo).Alias;
         end;

         if atributo is TTabelaEstrangeira then
         begin
           aliasEstrangeiro := TTabelaEstrangeira(atributo).Alias;
           if not strJuncao.IsEmpty then
             strJuncao := strJuncao + '  ';
           case TipoJuncao of
             ttInnerJoin: strJuncao := strJuncao + ' INNER JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' +
                                                   aliasEstrangeiro + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).Id ;
             ttLeftJoin: strJuncao := strJuncao + ' LEFT JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' +
                                                  aliasEstrangeiro + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).Id;
             ttRigthJoin: strJuncao := strJuncao + ' RIGTH JOIN  ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' +
                                                   aliasEstrangeiro + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).Id;
           end;
         end;
      end;
      for prop in tipo.GetProperties do
        for atributo in prop.GetAttributes do
        begin
          if not strCampos.IsEmpty then
             strCampos := strCampos + ',';
          if atributo is TChavePrimaria then
            strCampos := strCampos + alias + '.' + TChavePrimaria(atributo).Nome;
          if atributo is TCampoTexto then
            strCampos := strCampos + alias + '.' + TCampoTexto(atributo).Nome;
          if atributo is TCampoInteiro then
            strCampos := strCampos + alias + '.' + TCampoInteiro(atributo).Nome;
          if atributo is TCampoData then
            strCampos := strCampos + alias + '.' + TCampoData(atributo).Nome;
          if atributo is TCampoDataHora then
             strCampos := strCampos + alias + '.' + TCampoDataHora(atributo).Nome;
          if atributo is TCampoExtended then
            strCampos := strCampos + alias + '.' + TCampoExtended(atributo).Nome;
          if atributo is TCampoMonetario then
             strCampos := strCampos + alias + '.' + TCampoMonetario(atributo).Nome;
          if atributo is TCampoBooleano then
             strCampos := strCampos + alias + '.' + TCampoBooleano(atributo).Nome;
          if atributo is TCampoEstrangeiro then
             strCampos := strCampos + TCampoEstrangeiro(atributo).Alias + '.' + TCampoEstrangeiro(atributo).Nome;
          if atributo is TChaveEstrangeira then
             strCampos := strCampos + alias + '.' + TChaveEstrangeira(atributo).Nome;
          if atributo is TCampoFiltro then
          begin
            if prop.PropertyType.TypeKind = tkFloat then
            begin
              if CompareText(prop.PropertyType.Name, 'TDate') = 0 then
              begin
                 if not(dataInicio.IsEmpty) and not(dataFim.IsEmpty) then
                   strWhere := strWhere + ' BETWEEN ' + dataInicio + ' AND ' + dataFim ;
              end;
            end;
          end;
          if atributo is TSomatorio then
             strCampos := strCampos + ' SUM(' + alias + '.' + TSomatorio(atributo).Nome + ')';
          if atributo is TMedia then
             strCampos := strCampos + ' AVG(' + alias + '.' + TMedia(atributo).Nome + ')';
          if atributo is TMinimo then
             strCampos := strCampos + ' MIN(' + alias + '.' + TMinimo(atributo).Nome + ')';
          if atributo is TMaximo then
             strCampos := strCampos + ' MAX(' + alias + '.' + TMaximo(atributo).Nome + ')';
        end;
        //Formatar string que contém os campos.
        strCampos := FormatarString(strCampos);

        Lib := TLib<T>.Create;
        try
          strSelect := Lib.LocalizarSubstituir(strSelect, '[TABELA]', strTabela);
          strSelect := Lib.LocalizarSubstituir(strSelect, '[CAMPOS]', strCampos);
          strSelect := Lib.LocalizarSubstituir(strSelect, '[JUNCAO]', strJuncao);
          if strWhere.IsEmpty then
            Delete(strSelect, Pos('WHERE', strSelect), Length(strSelect))
          else strSelect := Lib.LocalizarSubstituir(strSelect, '[CONDICAO]', strWhere);

          FQuery.ExecSql(strSelect);
          json := Lib.QueryParaJson(FQuery, tqRDW);
        finally
          Lib.Free;
        end;
   finally
     contexto.Free;
     json.Free;
   end;
end;

//function TBaseDAO<T>.Listagem(obj: T; dataInicio,dataFim: string; const TipoJuncao: TTipoJoin = ttLeftJoin): IDAO<T>;
//var
//   contexto: TRttiContext;
//   tipo: TRttiType;
//   propriedade: TRttiProperty;
//   atributo: TCustomAttribute;
//   strSelect,strTabela,strCampos,strwhere, strJuncao, alias, aliasEStrangeiro: string;
//   Lib: TLib<T>;
//begin
//   Result := Self;
//   strSelect := 'SELECT TOP 100 [CAMPOS] FROM [TABELA] [JUNCAO] WHERE [CONDICAO]';
//   strTabela := '';
//   strCampos := '';
//   strJuncao := '';
//   strwhere := '';
//   contexto := TRttiContext.Create;
//   try
//     tipo := contexto.GetType(TObject(obj).ClassInfo);
//     for atributo in tipo.GetAttributes do
//     begin
//       if atributo is TTabela then
//       begin
//          alias := TTabela(atributo).Alias;
//          strTabela := strTabela + TTabela(atributo).Nome + '' + TTabela(atributo).Alias;
//       end;
//       if not strJuncao.IsEmpty then
//          strJuncao := strJuncao + '#10#13';
//
//       if atributo is TTabelaEstrangeira then
//       begin
//        aliasEstrangeiro := TTabelaEstrangeira(atributo).Alias;
//         case TipoJuncao of
//           ttInnerJoin: strJuncao := strJuncao + ' INNER JOIN ' + TTabelaEstrangeira(atributo).Nome + '' + TTabelaEstrangeira(atributo).Alias +
//                                                 ' ON ' + TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + '=' + TTabelaEstrangeira(atributo).Id;
//           ttLeftJoin: strJuncao := strJuncao + ' LEFT JOIN ' + TTabelaEstrangeira(atributo).Nome + '' + TTabelaEstrangeira(atributo).Alias +
//                                                  ' ON ' + TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + '=' + TTabelaEstrangeira(atributo).Id;
//           ttRigthJoin: strJuncao := strJuncao + ' RIGTH JOIN ' + TTabelaEstrangeira(atributo).Nome + '' + TTabelaEstrangeira(atributo).Alias +
//                                                  ' ON ' + TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + '=' + TTabelaEstrangeira(atributo).Id ;
//         end;
//       end;
//     end;
//
//     for propriedade in tipo.GetProperties do
//       for atributo in propriedade.GetAttributes do
//       begin
//         if not strCampos.IsEmpty then
//            strCampos := strCampos + ',';
//         if atributo is TCampoTexto then
//            strCampos := strCampos + alias + '.' + TCampoTexto(atributo).Nome;
//         if atributo is TCampoInteiro then
//            strCampos := strCampos + alias + '.' + TCampoInteiro(atributo).Nome;
//         if atributo is TCampoData then
//            strCampos := strCampos + alias + '.' + TCampoData(atributo).Nome;
//         if atributo is TCampoDataHora then
//            strCampos := strCampos + alias + '.' + TCampoDataHora(atributo).Nome;
//         if atributo is TCampoExtended then
//            strCampos := strCampos + alias + '.' + TCampoExtended(atributo).Nome;
//         if atributo is TCampoMonetario then
//            strCampos := strCampos + alias + '.' + TCampoMonetario(atributo).Nome;
//         if atributo is TCampoBooleano then
//            strCampos := strCampos + alias + '.' + TCampoBooleano(atributo).Nome;
//         if atributo is TCampoEstrangeiro then
//            strCampos := strCampos + aliasEStrangeiro + '.' + TCampoEstrangeiro(atributo).Nome;
//         if atributo is TSomatorio then
//            strCampos := strCampos + ' SUM(' + alias + '.' + TSomatorio(atributo).Nome + ')';
//         if atributo is TMedia then
//           strCampos := strCampos + ' AVG(' + alias + '.' + TMedia(atributo).Nome + ')';
//         if atributo is TMaximo then
//           strCampos := strCampos + ' MAX(' + alias + '.' + TMaximo(atributo).Nome + ')';
//         if atributo is TMinimo then
//           strCampos := strCampos + ' MIN(' + alias + '.' + TMinimo(atributo).Nome + ')';
//
//         if not strWhere.IsEmpty then
//            strWhere := strWhere + ' AND ';
//         if atributo is TCampoFiltro then
//         begin
//           if propriedade.PropertyType.TypeKind = tkFloat then
//           begin
//             if CompareText(propriedade.PropertyType.Name, 'TDateTime') > 0 then
//             begin
//               if not(dataInicio.IsEmpty) and not(dataFim.IsEmpty) then
//                 strWhere := strWhere + ' BETWEEN ' + dataInicio + ' AND ' + dataFim;
//             end;
//           end;
//         end;
//       end;
//       //Formatar a string que contém os campos.
//       strCampos := FormatarString(strCampos);
//
//       Lib := TLib<T>.Create;
//       try
//         strSelect := Lib.LocalizarSubstituir(strSelect, '[TABELA]', strTabela);
//         strSelect := Lib.LocalizarSubstituir(strSelect, '[CAMPOS]', strCampos);
//         if not strJuncao.IsEmpty then
//             strSelect := Lib.LocalizarSubstituir(strSelect, '[JUNCAO]', strJuncao)
//         else  strSelect := Lib.LocalizarSubstituir(strSelect, '[JUNCAO]', '');
//         if strWhere.IsEmpty then
//           Delete(strSelect, Pos('WHERE', strSelect), 1)
//         else strSelect := Lib.LocalizarSubstituir(strSelect, '[CONDICAO]', strwhere);
//
//         FQuery.SQL.Clear;
//         FQuery.SQL.Add(strSelect);
//         FQuery.Open;
//         Lib.QueryParaArrayJson(FQuery, tqRDW);
//       finally
//         Lib.Free;
//       end;
//   finally
//     contexto.Free;
//   end;
//end;

function TBaseDAO<T>.Listagem(obj: T; const TipoJuncao:TTipoJoin = ttLeftJoin; aTemLista: boolean = True): IDAO<T>;
var
   contexto: TRttiContext;
   tipo: TRttiType;
   propriedade: TRttiProperty;
   atributo: TCustomAttribute;
   strSelect,strTabela,strCampos,strWhere,strJuncao,tabela,alias,aliasEstrangeiro: string;
   Lib: TLib<T>;
   cds: TClientDataSet;
begin
   strSelect := 'SELECT TOP 100 [CAMPOS] FROM [TABELA] [JUNCAO] WHERE [CONDICAO]';
   strTabela := '';
   strCampos := '';
   strWhere := '';
   strJuncao := '';
   cds := TClientDataSet.Create(nil);
   contexto := TRttiContext.Create;
   try
     tipo := contexto.GetType(obj.ClassInfo);
     //Pegar o nome da Tabela.
     for atributo in tipo.GetAttributes do
     begin
       if atributo is TTabela then
       begin
          strTabela := strTabela + TTabela(atributo).Nome + ' ' + TTabela(atributo).Alias;
          tabela := TTabela(atributo).Nome;
          alias :=  TTabela(atributo).Alias;
       end;
       if not(strJuncao = '') then
          strJuncao := strJuncao + ' ';

       if atributo is TTabelaEstrangeira then
       begin
          aliasEstrangeiro := TTabelaEstrangeira(atributo).Alias;
          case TipoJuncao of
             ttInnerJoin:
                         begin
                            strJuncao := strJuncao + ' INNER JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias +
                                         ' ON ' + TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).Id;
                            break;
                         end;
             ttRigthJoin:
                         begin
                             strJuncao := strJuncao + ' RIGHT JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias +
                                          ' ON ' + TTabelaEstrangeira(atributo).Id + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro;
                             break;
                         end;
             ttLeftJoin:
                         begin
                           strJuncao := strJuncao + ' LEFT JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias +
                                        ' ON ' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).Id;
                           break;
                         end;
          end;
       end;
     end;



       //Pegar os campos.
       for propriedade in tipo.GetProperties do
         for atributo in propriedade.GetAttributes do
         begin
           if not(strCampos = '') then
              strCampos := strCampos + ',';

           if atributo is TCampoTexto then
              strCampos := strCampos + alias + '.' + TCampoTexto(atributo).Nome;

           if atributo is TCampoInteiro then
              strCampos := strCampos + alias + '.' + TCampoInteiro(atributo).Nome;

           if atributo is TCampoData then
              strCampos := strCampos + alias + '.' + TCampoData(atributo).Nome;

           if atributo is TCampoDataHora then
              strCampos := strCampos + alias + '.' + TCampoDataHora(atributo).Nome;

           if atributo is TCampoExtended then
              strCampos := strCampos + alias + '.' + TCampoExtended(atributo).Nome;

           if atributo is TCampoMonetario then
              strCampos := strCampos + alias + '.' + TCampoMonetario(atributo).Nome;

           if atributo is TCampoBooleano then
              strCampos := strCampos + alias + '.' + TCampoBooleano(atributo).Nome;

           if atributo is TChavePrimaria then
              strCampos := strCampos + alias + '.' + TChavePrimaria(atributo).Nome;

           if atributo is TChaveEstrangeira then
              strCampos := strCampos + alias + '.' + TChaveEstrangeira(atributo).Nome;

           if atributo is TCampoEstrangeiro then
              strCampos := strCampos + TCampoEstrangeiro(atributo).Alias + '.' + TCampoEstrangeiro(atributo).Nome;

           if atributo is TSomatorio then
           begin
             if TSomatorio(atributo).Ativo then
                strCampos := strCampos + 'SUM('+ alias + '.' + TSomatorio(atributo).Nome+')';
           end;

           if atributo is TMedia then
           begin
             if TMedia(atributo).Ativo then
               strCampos := strCampos + 'AVG('+ alias + '.' + TMedia(atributo).Nome+')';
           end;

           if atributo is TMinimo then
           begin
             if TMinimo(atributo).Ativo then
               strCampos := strCampos + 'MIN('+ alias + '.' + TMinimo(atributo).Nome+')';
           end;

           if atributo is TMaximo then
           begin
             if TMaximo(atributo).Ativo then
               strCampos :=  strCampos + 'MAX('+ alias + '.' + TMaximo(atributo).Nome+')';
           end;
         end;



     //Formatar a string que contém os campos.
     strCampos := FormatarString(strCampos);

     //Montar a query.
     Lib := TLib<T>.Create;
     try
        strSelect := Lib.LocalizarSubstituir(strSelect, '[TABELA]', strTabela);
        strSelect := Lib.LocalizarSubstituir(strSelect, '[JUNCAO]', strJuncao);
        if strWhere.IsEmpty then
          Delete(strSelect, Pos('WHERE', strSelect), Length(strSelect))
        else strSelect := Lib.LocalizarSubstituir(strSelect, '[CONDICAO]', strWhere);
        strSelect := Lib.LocalizarSubstituir(strSelect, '[CAMPOS]', strCampos);


       //Executar a query.
       {Modelo Cliente e Servidor.
       FQuery := TModelConexaoFactory.New.Query(2).ExecSql(strSelect);
       if (FQuery as TZQuery).RecordCount > 0 then
         Result := Lib.CopiarParaDataSet((FQuery as TZQuery));}

       //Rest Dataware n camadas.
       //Lib.CriarCds(obj, cds);//prepara o clientdataset para carregar os dados vindos do banco.
       //cds.Active := True;
       //cds.Open;
       FQuery.DataSet.DisableControls;
       FQuery.Open(strSelect);
       //Lib.CopiarParaDataSet(FQuery, TTipoQuery.tqRDW, cds);
       if aTemLista then
          FLista := Lib.QueryParaListaObjeto(FQuery, TTipoQuery.tqRDW);
       FQuery.DataSet.EnableControls;
     finally
       Lib.Free;
     end;
    finally
     contexto.Free;
     cds.Free;
   end;
end;

class function TBaseDAO<T>.New(aQuery: IModelQuery): IDAO<T>;
begin
   Result := Self.Create(aQuery);
end;

procedure TBaseDAO<T>.OnDataChange(Sender: TObject; Field: TField);
begin
   //Fazer o bind com o objeto.
   if (FLista.Count > 0) and (FDataSource.DataSet.RecNo - 1 <= FLista.Count) then
   begin
     if Assigned(FForm) then
       TRttiUtils<T>.BindClassToForm(FForm, FLista[FDataSource.DataSet.RecNo - 1]);
   end;
end;

function TBaseDAO<T>.PreencherParametro(aEntidade: T; aId: Variant): IDAO<T>;
var i: integer;
    Lista: TList<string>;
begin
   Result := Self;
   Lista := TList<string>.Create;
   TRttiUtils<T>.ListarCampos(Lista);
   try
     for i := 0 to Pred(Lista.Count) do
     begin
       if FQuery.Params.FindParam(Lista[i]) <> nil then
          FQuery.Params.ParamByName(Lista[i]).Value := aId;
     end;
   finally
     Lista.Free;
   end;
end;

function TBaseDAO<T>.Listagem(obj: T; aId: integer; const TipoJuncao: TTipoJoin = ttLeftJoin): IDAO<T>;
var
   contexto:               TRttiContext;
   prop:                   TRttiProperty;
   tipo:                   TRttiType;
   atributo:               TCustomAttribute;
   strSelect,
   strCampos,
   strTabela,
   strJuncao,
   strCondicao, alias:     string;
   Lib:                    TLib<T>;
begin
   Result := Self;
   strSelect :=    'SELECT [CAMPOS] FROM [TABELA] [JUNCAO] WHERE [CONDICAO]';
   strCampos :=    '';
   strTabela :=    '';
   strJuncao :=    '';
   strCondicao :=  '';
   contexto := TRttiContext.Create;
   try
     tipo := contexto.GetType(TObject(obj).ClassInfo);
     for atributo in tipo.GetAttributes do
     begin
       if atributo is TTabela then
       begin
         alias := TTabela(atributo).Alias;
         strTabela := strTabela + TTabela(atributo).Nome + ' ' + TTabela(atributo).Alias;
       end;

       if not strJuncao.IsEmpty then
          strJuncao := strJuncao + '  ';
       if atributo is TTabelaEstrangeira then
       begin
         case TipoJuncao of
           ttInnerJoin: strJuncao := strJuncao + ' INNER JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' +
                                                 TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro;
           ttLeftJoin: strJuncao := strJuncao + ' LEFT JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' +
                                                TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).Id;

           ttRigthJoin: strJuncao := strJuncao + ' RIGTH JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' +
                                                  TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro + ' = ' + alias + '.' + TTabelaEstrangeira(atributo).Id;
         end;
       end;
     end;

     for prop in tipo.GetProperties do
       for atributo in prop.GetAttributes do
       begin
         if not strCampos.IsEmpty then
            strCampos := strCampos + ',';

         if atributo is TChavePrimaria then
           strCampos := strCampos + alias + '.' + TChavePrimaria(atributo).Nome;
         if atributo is TCampoTexto then
           strCampos := strCampos + alias + '.' + TCampoTexto(atributo).Nome;
         if atributo is TCampoInteiro then
           strCampos := strCampos + alias + '.' + TCampoInteiro(atributo).Nome;
         if atributo is TCampoData then
           strCampos := strCampos + alias + '.' + TCampoData(atributo).Nome;
         if atributo is TCampoDataHora then
           strCampos := strCampos + alias + '.' + TCampoDataHora(atributo).Nome;
         if atributo is TCampoExtended then
           strCampos := strCampos + alias + '.' + TCampoExtended(atributo).Nome;
         if atributo is TCampoMonetario then
           strCampos := strCampos + alias + '.' + TCampoMonetario(atributo).Nome;
         if atributo is TCampoBooleano then
           strCampos := strCampos + alias + '.' + TCampoBooleano(atributo).Nome;
         if atributo is TCampoEstrangeiro then
           strCampos := strCampos + TCampoEstrangeiro(atributo).Alias + '.' + TCampoEstrangeiro(atributo).Nome;
         if atributo is TCampoFiltro then
         begin
           if not strCondicao.IsEmpty then
              strCondicao := strCondicao + ' AND ';
           if prop.PropertyType.TypeKind = tkInteger then
           begin
             if prop.GetValue(TObject(obj)).AsInteger > 0 then
               strCondicao := strCondicao + alias + '.' + TCampoFiltro(atributo).Nome + ' = ' + IntToStr(aId);
           end;
         end;
         if atributo is TSomatorio then
           strCampos := strCampos + ' SUM( ' + alias + '.' + TSomatorio(atributo).Nome + ') AS SOMA';
         if atributo is TMedia then
           strCampos := strCampos + ' AVG( ' + alias + '.' + TMedia(atributo).Nome + ') AS MEDIA';
         if atributo is TMinimo then
           strCampos := strCampos + ' MIN( ' + alias + '.' + TMinimo(atributo).Nome + ') AS MENOR';
         if atributo is TMaximo then
            strCampos := strCampos + ' MAX( ' + alias + '.' + TMaximo(atributo).Nome + ') AS MAIOR';
       end;
       //Formatar a string que contém os campos.
       strCampos := FormatarString(strCampos);

       Lib := TLib<T>.Create;
       try
         strSelect := Lib.LocalizarSubstituir(strSelect, '[CAMPOS]', strCampos);
         strSelect := Lib.LocalizarSubstituir(strSelect, '[TABELA]', strTabela);
         strSelect := Lib.LocalizarSubstituir(strSelect, '[JUNCAO]', strJuncao);
         if strCondicao.IsEmpty then
            Delete(strSelect, Pos('WHERE', strSelect), Length(strSelect))
         else strSelect := Lib.LocalizarSubstituir(strSelect, '[CONDICAO]', strCondicao);

         FQuery.SQL.Clear;
         FQuery.SQL.Add(strSelect);
         FQuery.DataSet.DisableControls;
         FQuery.Open;
         FQuery.DataSet.EnableControls;
         Lib.QueryParaObjeto(FQuery, tqRDW);
       finally
         Lib.Free;
       end;
   finally
     contexto.Free;
   end;
end;

function TBaseDAO<T>.Listagem(obj: T; aNome: string; const TipoJuncao:TTipoJoin = ttLeftJoin): IDAO<T>;
var
   contexto: TRttiContext;
   tipo: TRttiType;
   prop: TRttiProperty;
   atributo: TCustomAttribute;
   strSelect, strCampos, strTabela, strJuncao, strCondicao, alias: string;
   Lib: TLib<T>;
begin
  Result := Self;
  strSelect := 'SELECT [CAMPOS] FROM [TABELA] [JUNCAO] WHERE [COMDICAO]';
  strCampos := '';
  strTabela := '';
  strJuncao := '';
  strCondicao := '';
  contexto := TRttiContext.Create;
  try
    tipo := contexto.GetType(obj.ClassInfo);
    for atributo in tipo.GetAttributes do
    begin
      if atributo is TTabela then
      begin
        strTabela := strTabela + TTabela(atributo).Nome + ' ' + TTabela(atributo).Alias;
        alias := TTabela(atributo).Alias;
      end;
      if not strJuncao.IsEmpty then
        strJuncao := strJuncao + ' ';
      if atributo is TTabelaEstrangeira then
      begin
        case TipoJuncao of
          ttInnerJoin: strJuncao := strJuncao + ' INNER JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' + alias + '.' + TTabelaEstrangeira(atributo).Id + ' = ' + TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro;
          ttLeftJoin: strJuncao := strJuncao + ' LEFT JOIN  ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' 0N ' + alias + '.' + TTabelaEstrangeira(atributo).Id  + ' = ' + TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro;
          ttRigthJoin: strJuncao := strJuncao + ' RIGTH JOIN ' + TTabelaEstrangeira(atributo).Nome + ' ' + TTabelaEstrangeira(atributo).Alias + ' ON ' + alias + '.' + TTabelaEstrangeira(atributo).Id + ' = ' + TTabelaEstrangeira(atributo).Alias + '.' + TTabelaEstrangeira(atributo).IdEstrangeiro;
        end;
      end;
    end;

    if not strCampos.IsEmpty then
      strCampos := strCampos + ',';
    for prop in tipo.GetProperties do
      for atributo in prop.GetAttributes do
      begin
        if atributo is TChavePrimaria then
          strCampos := strCampos + alias + '.' + TChavePrimaria(atributo).Nome;
        if atributo is TCampoTexto then
          strCampos := strCampos + alias + '.' + TCampoTexto(atributo).Nome;
        if atributo is TCampoInteiro then
          strCampos := strCampos + alias + '.' + TCampoInteiro(atributo).Nome;
        if atributo is TCampoData then
          strCampos := strCampos + alias + '.' + TCampoData(atributo).Nome;
        if atributo is TCampoDataHora then
           strCampos := strCampos + alias + '.' + TCampoDataHora(atributo).Nome;
        if atributo is TCampoExtended then
          strCampos := strCampos + alias + '.' + TCampoExtended(atributo).Nome;
        if atributo is TCampoMonetario then
           strCampos := strCampos + alias + '.' + TCampoMonetario(atributo).Nome;
        if atributo is TCampoBooleano then
          strCampos := strCampos + alias + '.' + TCampoBooleano(atributo).Nome;
        if atributo is TCampoEstrangeiro then
          strCampos := strCampos + TCampoEstrangeiro(atributo).Alias + '.' + TCampoEstrangeiro(atributo).Nome;
        if atributo is TSomatorio then
          strCampos := strCampos + alias + '.' + TSomatorio(atributo).Nome;
        if atributo is TMedia then
          strCampos := strCampos + alias + '.' + TMedia(atributo).Nome;
        if atributo is TMinimo then
          strCampos := strCampos + alias + '.' + TMinimo(atributo).Nome;
        if atributo is TMaximo then
          strCampos := strCampos + alias + '.' + TMaximo(atributo).Nome;

        if not strCondicao.IsEmpty then
           strCondicao := strCondicao + ' AND ';
        if atributo is TCampoFiltro then
           strCondicao := strCondicao + alias + '.' + TCampoFiltro(atributo).Nome + ' = ' + aNome;
      end;
      //preparo a string de consulta
      strCampos := FormatarString(strCampos);

      Lib := TLib<T>.Create;
      try
        strSelect := Lib.LocalizarSubstituir(strSelect, '[TABELA]', strTabela);
        strSelect := Lib.LocalizarSubstituir(strSelect, '[JUNCAO]', strJuncao);
        strSelect := Lib.LocalizarSubstituir(strSelect, '[CAMPOS]', strCampos);
        if strCondicao.IsEmpty then
           Delete(strSelect, Pos('WHERE', strSelect), Length(strSelect))
        else strSelect := Lib.LocalizarSubstituir(strSelect, '[CONDICAO]', strCondicao);

        FQuery.DataSet.DisableControls;
        FQuery.Open(strSelect);
        FQuery.DataSet.EnableControls;
        FLista := Lib.QueryParaListaObjeto(FQuery, TTipoQuery.tqRDW);
      finally
        Lib.Free;
      end;

  finally
    contexto.Free;
  end;
end;

end.
